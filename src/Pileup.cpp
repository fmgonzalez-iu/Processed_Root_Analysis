#include  "../inc/Pileup.hpp"

/*----------------------------------------------------------------------
 * Author: Frank M. Gonzalez
 * 
 * This class contains the rate dependent (in particular pileup) events 
 * for a given run. 
 * 
 * There are two competing rate dependent effects involved in our data.
 * One of these is deadtime, which is corrected for by:
 * 
 * Rate_real = Rate_meas ( 1 - \tau * Rate_meas) 
 * 
 * Where \tau is the dead time during that particular event.
 * The other rate dependent effect is "Pileup" or "Fat Tail". Here there's
 * a long tail of photons generated by the scintillator
 * 
 * -------------------------------------------------------------------*/

Pileup::Pileup(Run* run, double bkg, double bkgC, double start, double end) {
	// Initializer -- set things to 0 first
	this->ph_f = 0;
	this->ph_b = 0;
	this->coinc = 0;
	this->coincB = 0;
	this->N_mu = 0;
	this->N_max = 0;
	this->dt_mu = 0;
	this->tau = 0;
	this->logGamma.clear();
	
	// Our starting time goes here:
	this->start = start;
	this->end = end;
	
	// Now let's load some stuff from the initial run
	this->peThresh = run->getPeSum();
	this->LoadSingStats(run);
	this->LoadCoincStats(run);
	
	this->SetBackground(bkg);
	this->SetCoincBackground(bkgC);
	this->CalculateTau();

}

Pileup::~Pileup() {
	// Deconstructor
}

void Pileup::SetBackground(double bkg) {
	// background input is rate
	this->ph_b = bkg*(this->end - this->start);
}

double Pileup::GetBackground() {
	return ph_b;
}

void Pileup::SetCoincBackground(double bkgC) {
	this->coincB = bkgC*(this->end - this->start);
}

double Pileup::GetCoincBackground() {
	return coincB;
}

void Pileup::LoadCoincStats(Run* run) {
	
	
	
	std::vector<coinc_t> coin_vec = run->getCoincCounts(
		[](coinc_t x)->coinc_t{return x;},
		[this](coinc_t x)->bool{return (x.realtime > this->start && x.realtime < this->end);}
	);
	this->LoadCoincStatsVec(coin_vec);
	
	std::vector<counting_t> stats = run->getCountingAvgs(3,
					[](coinc_t x)->coinc_t{return x;},
					[this](coinc_t x)->bool{return (x.realtime > this->start && x.realtime < this->end);}
	);
	
	//printf("PMTA Coinc HITS = %lu; ",run->pmtACoincHits.size());
	//printf("PMTB Coinc HITS = %lu; ",run->pmtBCoincHits.size());
	//printf("Coincidences = %lu\n", coin_vec.size());
	
	for (size_t ii = 0; ii < coin_vec.size(); ii++){
		unsigned long indexoo = coin_vec.at(ii).index;
		size_t pmtA = run->pmtACoincHits.at(indexoo).size();
		size_t pmtB = run->pmtBCoincHits.at(indexoo).size();
		int pmt1 = coin_vec.at(ii).pmt1;
		int pmt2 = coin_vec.at(ii).pmt2;
		
		std::vector<input_t> coincPMTHits;
		
		
		//printf("%lu, pmtA = %lu, pmtB = %lu; pmt1 = %d, pmt2 = %d\n",indexoo,pmtA,pmtB,pmt1,pmt2);
	}
		
	
}

void Pileup::LoadCoincStatsVec(std::vector<coinc_t> coin_vec) {
	// Load averages from the coincidence vector
	if (coin_vec.size() == 0) {return;}
		
	// Previously defined coincidence data 
	// (so that this is generizable to pseudo-coincidences)
	this->coinc = (double)coin_vec.size() + getDeadTimeCoinc(coin_vec, start, end);
	
	// Also need to know average length and photons of coincidences:
	this->dt_mu = std::accumulate(coin_vec.begin(), coin_vec.end(), 0.0, [](double t, coinc_t x)->double{return t + (x.length);}) / (double)coin_vec.size();// Average length of coincidence
	this->N_mu  = std::accumulate(coin_vec.begin(), coin_vec.end(), 0.0, [](double N, coinc_t x)->double{return N + (double)(x.pmt1 + x.pmt2);}) / (double)coin_vec.size(); // Average number of photons in coincidences
	
	// Need to initialize the log_gamma function so that we don't have to recalculate it for each coincidence
	auto maxE = std::max_element(coin_vec.begin(),coin_vec.end(),[](coinc_t x, coinc_t y)->bool{return (x.pmt1 + x.pmt2) < (y.pmt1 + y.pmt2);}); // Also the max number of photons in the coincidence
	this->N_max = (*maxE).pmt1+(*maxE).pmt2;
		
	// Make sure we have photons greater than threshold
	if (this->N_max <= this->peThresh) { return; }
	
	this->logGamma.clear(); // Pre-initialize log gamma so that it's faster
	std::vector<double> gVec;
	for (int i = 0; i < (this->N_max); i++) {
		double lnG = lgamma((double)(i+1));
		gVec.push_back(lnG);
	}
	this->logGamma = gVec;
	
}

void Pileup::LoadSingStats(Run* run) {
	
	// Load singles from data.
	// Have to treat PMT1 and PMT2 separately due to deadtime 
	int c1 = run->getCoinC1() + run->getMCSOff();
	std::vector<input_t> pmt1_vec = run->getCounts(
		[](input_t x)->input_t{return x;},
		[c1,this](input_t x)->bool{return (x.ch  == c1) 
										 && (x.realtime > this->start && x.realtime < this->end);}
	);
	
	int c2 = run->getCoinC2() + run->getMCSOff();
	std::vector<input_t> pmt2_vec = run->getCounts(
		[](input_t x)->input_t{return x;},
		[c2,this](input_t x)->bool{return (x.ch  == c2) 
										 && (x.realtime > this->start && x.realtime < this->end);}
	);
	
	// Care about ph_f (foreground photons)
	this->LoadSingStatsVec(pmt1_vec,pmt2_vec);
	
}

void Pileup::LoadSingStatsVec(std::vector<input_t> pmt1_vec, std::vector<input_t> pmt2_vec) {
	// Overloading to put in unique singles vectors (i.e. removing stuff) 
	
	double pmt1 = (double)pmt1_vec.size() + getDeadTimeSing(pmt1_vec, this->start, this->end);
	double pmt2 = (double)pmt2_vec.size() + getDeadTimeSing(pmt2_vec, this->start, this->end);
	
	this->ph_f = pmt1 + pmt2;
}
void Pileup::LoadSingStatsVec(std::vector<input_t> pmt_vec) {
	double pmt = (double)pmt_vec.size() + getDeadTimeSing(pmt_vec, this->start, this->end);
	
	this->ph_f = pmt;
}
void Pileup::LoadSingStatsVec(std::vector<coinc_t> pmt_vec) {
	double pmt = (double)pmt_vec.size() + getDeadTimeCoinc(pmt_vec, this->start,this->end);
	
	this->ph_f = pmt;
}


void Pileup::CalculateTau() {
	this->tau = 0.;
	
	// Check that we have initial parameters
	if (this->ph_f < 1){printf("ph_f not found\n");return;}
	if (this->ph_b < 1){printf("ph_b not found\n");return;}
	if (this->coinc < 1){printf("coinc not found\n");return;}
	if (this->N_mu <= this->peThresh){printf("N_mu not found\n");return;}
	if (this->dt_mu < 16*NANOSECOND){printf("dt_mu not found\n");return;}
	printf("N_mu = %f, dt_mu = %e\n",this->N_mu,this->dt_mu);
	// Now let's calculate
	double amp = (ph_f - ph_b) / (coinc-coincB);	
	if (amp < this->N_mu || std::isfinite(amp)==false) {this->tau = 0; return;} // Need a finite amplitude
	double t = -dt_mu / log(1. - N_mu / amp);
	if (std::isfinite(t)) { this->tau = t; return;}
	else { this->tau = 0; return; }
}

double Pileup::GetTau() {
	return this->tau;
}

double Pileup::GetAmplitude() {
	double amp = (ph_f - ph_b) / (coinc-coincB);
	if (amp < 0 || std::isfinite(amp)==false) {return 0;} // Need a finite amplitude
	return amp;
}

double Pileup::CalculatePileup(std::vector<coinc_t> coinc_vec) {
	// And here we're actually calculating the pileup based on the prev.
	// initialized counts
	
	if (coinc_vec.size() < 2 || this->coinc < 2) {return 0;} // Pileup only works for multiple coincideences
	
	// Expected amplitude of each event
	double amp = (this->ph_f - this->ph_b) / (this->coinc - this->coincB);
	double m_prev = 0.; // Photons from previous event
	
	
	if (amp < 0 || std::isfinite(amp)==false) {return 0;} // Need a finite amplitude
	double corr = 0;
	for (size_t ii = 1; ii < coinc_vec.size(); ii++) {
		
		double dt = coinc_vec.at(ii).realtime - coinc_vec.at(ii-1).realtime;
		double dt_2 = dt + coinc_vec.at(ii).length; // Adding length
		// Note that we're assuming \Sum{\kappa_i \tau_i} = 1
		double prob_int = (exp(-dt / tau) - exp(-dt_2 / tau)); // Probability of pileup/photon
		
		double m_i = (amp + m_prev) * prob_int;
		m_prev = m_i;
		if (m_i < 1e-8) { continue;} // Arbitrary minimum precision
		
		// Now we sum the poisson probability of each of these
		double prob = 1;
		int NPE = coinc_vec.at(ii).pmt1 + coinc_vec.at(ii).pmt2;
		// Loop through the number of photons we can afford to lose
		for (int jj = 0; jj < NPE + 1 - this->peThresh; jj++) {
			// Safe LogGamma Caching:
			if ((int)(this->logGamma.size()) > (jj)) { 
				double lnP = (double)(jj) * log(m_i) - m_i - this->logGamma[jj];
				prob -= exp(lnP);
			} else { 
				// In the event that we haven't defined this logGamma term (i.e. weird timing thingy)
				double lnP = (double)(jj) * log(m_i) - m_i - lgamma((double)(jj+1));
				prob -= exp(lnP);
			}
		}
		corr -= prob;
	}
	return corr;
}

/* This is a single-exponential pileup */
/*double getPileUpTau(Run* run, std::vector<coinc_t> coin_vec, double bkgRate, double start, double end) {
	// Assume that all photons above "background" are from "coincidences"
	// that are uncounted by our algorithm. Also assume the form of coinc.
	// events are the sum of exponentials. Then, find:
	// \frac{x - y}{z} = \frac{N_m}{\Sum_{j}{\kappa_j \tau_j \left(1 - e^{-\delta t_m / \tau_j}\right)}}
	//
	// Here we're solving for the "lifetime" for scintillator glow, assuming single exponential

	double tau = 0.;
	if (coin_vec.size() == 0) { return tau; } // Need coincidences!

	
		
	// Over the whole unload, want to know:
	double ph_f = pmt1 + pmt2; // Number of photons in foregrounds
	double ph_b = bkgRate * (end - start); // Number of photons in backgrounds
	
	double amp = (ph_f - ph_b) / coin; // Amplitude of average coinc. event
		
	// Exponential lifetime of coincidence glow
	tau = - dt_m /  log( 1. - (N_m / amp));
	
	return tau;
}

/* How many coincidences do we lose, given single tau */
/*double getPileUpCorr(std::vector<coinc_t> coinc, double tau, double amp, int PE) { 
	// With a given (single) tau, we need to deweight coincidences
	// based on their interarrival times. 
	//
	// Rather than doing a factorial
	
	
	double poisson = mu_i**pe * exp(mu_i) / pe!
	
}*/


//----------------------------------------------------------------------
// I'm putting the deadtime functions in this section (so that things compile better)
//----------------------------------------------------------------------
double getDeadTimeSing(std::vector<input_t> &cts, double start, double end) {
	// Singles deadtime. Deadtime is a part of the input_t class
	// hardcoded in 16ns unless otherwise changed

	// deadtime counts defined here
	double deadTimeCounts = 0.0;
	if(cts.size() < 1) {
		return deadTimeCounts;
	}

	int counts = 0;
	double totDT = 0.0;
	double dtS = 0.1; // Divide into 0.1s bins
	
	// Deadtime is assumed to be the average of the coincidence window length
	int time=floor(cts.front().realtime / dtS);
	//double peSumWindow = run->getPeSumWindow();
	bool test = false;
	for(auto cIt = cts.begin(); cIt < cts.end(); cIt++) {
		
		//if ((*cIt).deadtime != 16*NANOSECOND) { test=true; printf("Deadtime: %f\nRate:%f\n",(*cIt).deadtime/NANOSECOND,(*cIt).rate);}
		if(floor((*cIt).realtime / dtS) > time) {
			//if (test) { printf("counts %d, totDT %f\n",counts,totDT); } 
			deadTimeCounts += (double)counts / (1.0 - totDT / dtS)  - (double)counts;
			counts = 0;
			totDT = 0.0;
			time = floor((*cIt).realtime / dtS);
			test = false;
		}
		totDT += (*cIt).deadtime; // Add the deadtime of each event
		counts++;
	}
	
	return deadTimeCounts;		
			
}

double getDeadTimeCoinc(std::vector<coinc_t> &cts, double start, double end) {
	
	//int coincType = run->getCoincMode();

	double deadTimeCounts = 0.0;
	//std::vector<coinc_t> cts = run->getCoincCounts(
	//		[](coinc_t x)->coinc_t{return x;},
	//		[start, end](coinc_t x)->bool{return (x.realtime > start && x.realtime < end);});
			
	if(cts.size() < 1) {
		return deadTimeCounts;
	}

	int counts = 0;
	double totCoincL = 0.0;
	double dtS = 0.1; // Divide into 0.1s bins
	
	// Deadtime is assumed to be the average of the coincidence window length
	int time=floor(cts.front().realtime / dtS);
	//double peSumWindow = run->getPeSumWindow();
	for(auto ctsIterator = cts.begin(); ctsIterator < cts.end(); ctsIterator++) {
		if(floor((*ctsIterator).realtime / dtS) > time) {
			// n = m / (1 - m tau)
			// n = (cts / dt) / (1 - (cts / dt) (totTau / cts) )
			// n = (cts / dt) / (1 - totTau / dt) 
			// dtC = n * dt 
			// dtC = cts / ( 1 - totTau / dt)
			deadTimeCounts += (double)counts / (1.0 - totCoincL / dtS)  - (double)counts;
			counts = 0;
			totCoincL = 0.0;
			time=floor((*ctsIterator).realtime / dtS);
		}
		totCoincL += (*ctsIterator).length;
		counts++;
	}
	
	return deadTimeCounts;
}
